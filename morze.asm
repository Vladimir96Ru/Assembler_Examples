SGSTACK SEGMENT PARA STACK 'STACK'
DB 32 DUP(?)
SGSTACK ENDS
 
DATA SEGMENT PARA PUBLIC 'DATA'
point_delay dw  1   ; длительность звука "точка" 
dash_delay  dw  3   ; длительность звука "тире" 
morse   label   byte        ; таблица преобразования символов в код морзе (1 - точка, 2 - тире)
    db  'a', 1, 2, 0
    db  'b', 2, 1, 1, 1, 0
    db  'c', 2, 1, 2, 1, 0
    db  'd', 2, 1, 1, 0
    db  'e', 1, 0
    db  'f', 1, 1, 2, 1, 0
    db  'g', 2, 2, 1, 0
    db  'h', 1, 1, 1, 1, 0
    db  'i', 1, 1, 0
    db  'j', 1, 2, 2, 2, 0
    db  'k', 2, 1, 2, 0
    db  'l', 1, 2, 1, 1, 0
    db  'm', 2, 2, 0
    db  'n', 2, 1, 0
    db  'o', 2, 2, 2, 0
    db  'p', 1, 2, 2, 1, 0
    db  'q', 2, 2, 1, 2, 0
    db  'r', 1, 2, 1, 0
    db  's', 1, 1, 1, 0
    db  't', 2, 0
    db  'u', 1, 1, 2, 0
    db  'v', 1, 1, 1, 2, 0
    db  'w', 1, 2, 2, 0
    db  'x', 2, 1, 1, 2, 0
    db  'y', 2, 1, 2, 2, 0
    db  'z', 2, 2, 1, 1, 0
 
    db  '1', 1, 2, 2, 2, 2, 0
    db  '2', 1, 1, 2, 2, 2, 0
    db  '3', 1, 1, 1, 2, 2, 0
    db  '4', 1, 1, 1, 1, 2, 0
    db  '5', 1, 1, 1, 1, 1, 0
    db  '6', 2, 1, 1, 1, 1, 0
    db  '7', 2, 2, 1, 1, 1, 0
    db  '8', 2, 2, 2, 1, 1, 0
    db  '9', 2, 2, 2, 2, 1, 0
    db  '0', 2, 2, 2, 2, 2, 0
 
tab_length  dw  $ - offset morse    ; длина таблицы в байтах - текущее смещение минус адрес начала таблицы
 
DATA ENDS
 
CODE SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:CODE, DS:DATA, SS:SGSTACK
 
start:
    mov ax, DATA        ; загрузить в DS
    mov ds, ax      ; селектор сегмента данных (правильнее не селектор а сегментный адрес, тут же не защищенный режим)))
    mov es, ax      ; команда scasb работает с парой es:[di], поэтому спроецируем es в адресное пространство сегмента данных
_loop:
    xor ax, ax      ; ждем клавиатуру
    int 16h     ; прерывание
    or  al, al      ; функциональная клавиша?
    jz  _loop       ; не обрабатываем
    cmp al, 27      ; ESC ?
    jz  EXIT        ; если да - выходим
    cmp al, ' '
    jz  _space
    lea di, morse       ; загружаем адрес таблицы в регистр di
    mov cx, tab_length  ; размер таблицы
    repne   scasb       ; ищем в таблице символ набранный с клавиатуры
    jnz _loop       ; символ не найден
    mov si, di      ; si = di - позиция в таблице найденого символа
_out_morseCode:
    mov bx, point_delay ; Пауза между знаками в букве - одна точка
    call    sleep
    lodsb           ; загружаем цифру из таблицы
    cmp al, 1       ; цифра 1?
    jz  _point      ; значит выводим точку
    cmp al, 2       ; 2?
    jz  _dash       ; выводим тире
    or  al, al      ; 0?
    jz  _loop       ; дошли до конца строки
    jmp _loop       ; на эту строку перейдем только если есть ошибка в таблице
_point:
    mov ah, 2       ; функция вывода символа на экран
    mov dl, '*'     ; * у нас точка
    int 21h     ; выводим ее
 
    mov dx, point_delay ; устанавливаем паузу соответствующую точке
    call    beep        ; пищим
    jmp _out_morseCode  ; на следующий символ в таблице
_dash:
    mov ah, 2
    mov dl, '-'     ; тире
    int 21h     ; рисуем символ
 
    mov dx, dash_delay  ;  пауза для тире
    call    beep        ; звучим
    jmp _out_morseCode  ; на следующий символ в таблице
_space:
    mov ah, 2
    mov dl, ' '     ; пробел вообще то в морзянке отсутствует, вместо него пауза 7 точек, но мы для красоты нарисуем и его
    int 21h     ; рисуем символ
    jmp _loop
 
EXIT:
    XOR AL, AL      ; выход в OS
    MOV AH, 4CH
    INT 21H
 
; издает звук с частотой 1 KHz
; частота на динамике задается делителем (rate = 1 193 180 / devisor (Hz)), у нас 1000 Гц, т.е. делитель = 1 193 180 / 1000 = 0x4a9
; длителиность задается в регистре dx
beep    proc    near
    push    dx      ; сохраним значение длительности
    mov al, 10110110b   ; канал 2, режим 3
    out 43h, al
    mov al, 9ah          ; младший байт делителя частоты 4a9h
    out 42h, al
    mov al, 4h      ; старший байт делителя частоты
    out 42h, al
    in  al, 61h     ; текущее состояние порта 61h в AL
    or  al, 00000011b   ; установить биты 0 и 1 в 1 (разрешить работу динамика и включить его)
    out 61h, al     ; теперь динамик включен
 
    pop bx      ; восстановим значение длительности
    call    sleep       ; пауза
 
    in  al, 61h
    and al, 11111100b   ; обнулить младшие два бита
    out 61h, al     ; теперь динамик выключен
    ret
beep    endp
 
; задержка
; длителиность паузы в регистре bx
sleep   proc    near
    xor ah, ah      ; получение текущего значения счетчика
    int 1ah     ; прерывание таймера
    add dx, bx      ; прибавляем нужную нам задержку
    mov bx, dx      ; сохраняем ее
_wait:
    int 1ah     ; получение текущего значения счетчика
    cmp dx, bx      ; сравниваем с искомым
    jb  _wait       ; если не равен, то повторяем снова
    ret
sleep   endp
 
CODE ENDS
END START
